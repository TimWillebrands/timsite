---
export interface Props {
    startColor?: string;
    endColor?: string;
}

const { startColor = "#8af0e0", endColor = "#fef3f2" } = Astro.props;

// Function to convert hex to RGB
function hexToRgb(hex: string) {
    const r = Number.parseInt(hex.slice(1, 3), 16);
    const g = Number.parseInt(hex.slice(3, 5), 16);
    const b = Number.parseInt(hex.slice(5, 7), 16);
    return { r, g, b };
}

// Function to convert RGB to hex
function rgbToHex(rIn: number, gIn: number, bIn: number) {
    const r = Math.max(0, Math.min(255, rIn));
    const g = Math.max(0, Math.min(255, gIn));
    const b = Math.max(0, Math.min(255, bIn));
    return `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).padStart(6, "0")}`;
}

// Function to linearly interpolate between two colors
function interpolateColor(
    color1Hex: string,
    color2Hex: string,
    factor: number,
) {
    const color1 = hexToRgb(color1Hex);
    const color2 = hexToRgb(color2Hex);

    const r = Math.round(color1.r + (color2.r - color1.r) * factor);
    const g = Math.round(color1.g + (color2.g - color1.g) * factor);
    const b = Math.round(color1.b + (color2.b - color1.b) * factor);

    return rgbToHex(r, g, b);
}

const white = "#ffffff";

const g02_stop1_color = interpolateColor(startColor, white, 0.7); // Towards white from startColor
const g02_stop2_color = interpolateColor(endColor, white, 0.8); // Towards white from endColor
const rect_fill_color = interpolateColor(endColor, white, 0.9); // Even more towards white from endColor
---

<svg
    class="background"
    width="800"
    height="600"
    x-data="{
        t1: Math.random() * 10,
        t2: Math.random() * 10,
        t3: Math.random() * 10,
        t4: Math.random() * 10,
        t5: Math.random() * 10,

        get rx() { return (75 + Math.sin(this.t1) * 1) + '%' },
        get ry() { return (45 + Math.sin(this.t2) * 1) + '%' },

        get r() { return (35 + Math.sin(this.t3) * 1) + '%' },
        get cx() { return (50 + Math.sin(this.t4) * 3) + '%' },
        get cy() { return (50 + Math.cos(this.t4) * 3) + '%' },

        get g_rot() { return Math.sin(this.t5) * 45; },

        get hue() { return Math.sin(this.t2) * 2 },
        get style() {
            return `filter: hue-rotate(${this.hue}deg) saturate(50%)`
        }
    }"
    x-init="async () => {
        while(true) {
            await $nextTick();
            t1 += 0.002 + Math.random() * 0.000001;
            t2 += 0.003 + Math.random() * 0.000001;
            t3 += 0.005 + Math.random() * 0.000001;
            t4 += 0.004 + Math.random() * 0.000001;
            t5 += 0.006 + Math.random() * 0.000001;
        }
    }"
    :style="style"
    transition:animate="none"
>
    <linearGradient id="g01" :gradientTransform="'rotate(' + g_rot + ')'">
        <stop stop-color={startColor}></stop>
        <stop stop-color={endColor} offset="1"></stop>
    </linearGradient>
    <linearGradient id="g02">
        <stop stop-color={g02_stop1_color} offset=".2"></stop>
        <stop stop-color={g02_stop2_color} offset="1"></stop>
    </linearGradient>
    <g>
        <rect width="100%" height="100%" fill={rect_fill_color}></rect>
        <ellipse :rx="rx" :ry="ry" fill="url(#g01)"></ellipse>
        <circle :r="r" :cx="cx" :cy="cy" fill="url(#g02)"></circle>
    </g>
</svg>

<style>
    /* Background stuff inspired by: FrontendMasters.com */
    .background {
        width: 100%;
        height: 100%;
        position: absolute;
        top: 0;
        left: 0;
        z-index: -1;
    }

    g {
        /*filter: url("noise.svg#n");*/
    }

    rect,
    ellipse,
    circle {
        transform-box: fill-box;
        transform-origin: 50%;
    }

    ellipse,
    circle {
        cx: 50%;
        cy: 50%;
        filter: blur(calc(4vmin + 4vmax));
    }

    .background ellipse {
        translate: -10% -5%;
        rotate: -22.5deg;
    }
    .background circle {
        cy: 57.5%;
        rotate: 45deg;
    }
</style>
